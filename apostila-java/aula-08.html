<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aula 08 - Arquitetura Hexagonal</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="back-link">â† Voltar ao Menu</a>
            <h1>Aula 08 - Conceito de Arquitetura Hexagonal</h1>
            <p class="subtitle">DomÃ­nio, ports, adapters e separaÃ§Ã£o de responsabilidades</p>
        </header>

        <div class="content">
            <section class="section">
                <h2>ğŸ“š Conectando com as Aulas Anteriores</h2>
                <div class="concept-box">
                    <p>
                        Nas <strong>Aulas 03 a 07</strong>, vocÃª aprendeu Spring Boot, JPA, DTOs, validaÃ§Ãµes, Docker 
                        e Swagger. VocÃª jÃ¡ tem uma API funcional! Mas agora vamos aprender uma <strong>arquitetura 
                        profissional</strong> que vai tornar seu cÃ³digo muito mais organizado, testÃ¡vel e fÃ¡cil de manter.
                    </p>
                    <p>
                        <strong>O que vocÃª jÃ¡ sabe:</strong> Spring Boot, Controllers, Services, Repositories, 
                        DTOs, JPA, Dependency Injection
                    </p>
                    <p>
                        <strong>O que vamos aprender agora:</strong> Arquitetura Hexagonal (Ports and Adapters), 
                        separaÃ§Ã£o entre domÃ­nio e infraestrutura, como organizar cÃ³digo profissional e por que isso 
                        Ã© importante em projetos reais
                    </p>
                    <div class="tip-box">
                        <strong>ğŸ’¡ MudanÃ§a de mentalidade:</strong> AtÃ© agora, vocÃª misturava lÃ³gica de negÃ³cio com 
                        cÃ³digo de infraestrutura (JPA, Spring). A Arquitetura Hexagonal vai te ensinar a separar isso, 
                        tornando seu cÃ³digo muito mais profissional e testÃ¡vel.
                    </div>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ›ï¸ O que Ã© Arquitetura Hexagonal?</h2>
                
                <div class="concept-box">
                    <h3>TambÃ©m conhecida como Ports and Adapters</h3>
                    <p>Arquitetura Hexagonal (criada por Alistair Cockburn) isola a lÃ³gica de negÃ³cio do mundo externo, 
                    tornando a aplicaÃ§Ã£o independente de frameworks, bancos de dados, interfaces de usuÃ¡rio, etc.</p>
                    
                    <ul>
                        <li><strong>DomÃ­nio no centro:</strong> Regras de negÃ³cio puras, sem dependÃªncias externas</li>
                        <li><strong>Ports:</strong> Interfaces que definem contratos (entrada e saÃ­da)</li>
                        <li><strong>Adapters:</strong> ImplementaÃ§Ãµes concretas dos ports</li>
                        <li><strong>InversÃ£o de dependÃªncia:</strong> Camadas externas dependem do domÃ­nio, nÃ£o o contrÃ¡rio</li>
                    </ul>
                </div>

                <div class="concept-box">
                    <h3>BenefÃ­cios</h3>
                    <ul>
                        <li>âœ… Testabilidade: DomÃ­nio pode ser testado isoladamente</li>
                        <li>âœ… Flexibilidade: Trocar banco de dados sem afetar regras de negÃ³cio</li>
                        <li>âœ… Manutenibilidade: CÃ³digo organizado e fÃ¡cil de entender</li>
                        <li>âœ… Escalabilidade: FÃ¡cil adicionar novos adapters (novas interfaces)</li>
                        <li>âœ… IndependÃªncia: NÃ£o acoplado a frameworks especÃ­ficos</li>
                    </ul>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ“ Estrutura das Camadas</h2>
                
                <div class="concept-box">
                    <h3>1. DomÃ­nio (Domain)</h3>
                    <p><strong>Regras de negÃ³cio puras</strong> - sem dependÃªncias externas</p>
                    <div class="code-block">
<pre>package com.exemplo.domain;

// Entidade de domÃ­nio (sem anotaÃ§Ãµes JPA)
public class Task {
    private Long id;
    private String titulo;
    private String descricao;
    private boolean concluida;
    
    // Construtor
    public Task(String titulo, String descricao) {
        this.titulo = titulo;
        this.descricao = descricao;
        this.concluida = false;
    }
    
    // Regras de negÃ³cio
    public void marcarComoConcluida() {
        if (this.concluida) {
            throw new IllegalStateException("Tarefa jÃ¡ estÃ¡ concluÃ­da");
        }
        this.concluida = true;
    }
    
    public void atualizarTitulo(String novoTitulo) {
        if (novoTitulo == null || novoTitulo.isBlank()) {
            throw new IllegalArgumentException("TÃ­tulo nÃ£o pode ser vazio");
        }
        this.titulo = novoTitulo;
    }
    
    // Getters
    public Long getId() { return id; }
    public String getTitulo() { return titulo; }
    // ...
}</pre>
                    </div>
                </div>

                <div class="concept-box">
                    <h3>2. Application - Ports (Interfaces)</h3>
                    <p><strong>Contratos</strong> que definem como o mundo externo interage com o domÃ­nio</p>
                    
                    <h4>Ports de Entrada (Inbound - Use Cases)</h4>
                    <div class="code-block">
<pre>package com.exemplo.application.port.in;

import com.exemplo.domain.Task;

public interface CreateTaskUseCase {
    Task criar(CriarTaskCommand command);
}

public interface ListTasksUseCase {
    List&lt;Task&gt; listar();
}

public interface CompleteTaskUseCase {
    void completar(Long taskId);
}</pre>
                    </div>

                    <h4>Ports de SaÃ­da (Outbound - Repositories)</h4>
                    <div class="code-block">
<pre>package com.exemplo.application.port.out;

import com.exemplo.domain.Task;
import java.util.Optional;

public interface TaskRepositoryPort {
    Task salvar(Task task);
    Optional&lt;Task&gt; buscarPorId(Long id);
    List&lt;Task&gt; listar();
    void deletar(Long id);
}</pre>
                    </div>
                </div>

                <div class="concept-box">
                    <h3>3. Application - Services (ImplementaÃ§Ã£o dos Use Cases)</h3>
                    <div class="code-block">
<pre>package com.exemplo.application.service;

import com.exemplo.application.port.in.CreateTaskUseCase;
import com.exemplo.application.port.in.CriarTaskCommand;
import com.exemplo.application.port.out.TaskRepositoryPort;
import com.exemplo.domain.Task;

@Service
public class CreateTaskService implements CreateTaskUseCase {
    
    private final TaskRepositoryPort repository;
    
    public CreateTaskService(TaskRepositoryPort repository) {
        this.repository = repository;
    }
    
    @Override
    public Task criar(CriarTaskCommand command) {
        // Criar entidade de domÃ­nio
        Task task = new Task(command.titulo(), command.descricao());
        
        // Salvar via port (nÃ£o sabe se Ã© JPA, MongoDB, etc)
        return repository.salvar(task);
    }
}</pre>
                    </div>
                </div>

                <div class="concept-box">
                    <h3>4. Infrastructure - Adapters (ImplementaÃ§Ãµes)</h3>
                    <p><strong>ImplementaÃ§Ãµes concretas</strong> dos ports</p>
                    
                    <h4>Adapter de PersistÃªncia (JPA)</h4>
                    <div class="code-block">
<pre>package com.exemplo.infrastructure.persistence;

import com.exemplo.application.port.out.TaskRepositoryPort;
import com.exemplo.domain.Task;
import com.exemplo.infrastructure.persistence.entity.TaskEntity;
import com.exemplo.infrastructure.persistence.mapper.TaskMapper;

@Repository
public class JpaTaskRepositoryAdapter implements TaskRepositoryPort {
    
    private final TaskJpaRepository jpaRepository;
    private final TaskMapper mapper;
    
    @Override
    public Task salvar(Task task) {
        TaskEntity entity = mapper.toEntity(task);
        TaskEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }
    
    @Override
    public Optional&lt;Task&gt; buscarPorId(Long id) {
        return jpaRepository.findById(id)
            .map(mapper::toDomain);
    }
    // ...
}</pre>
                    </div>

                    <h4>Adapter de Entrada (Controller)</h4>
                    <div class="code-block">
<pre>package com.exemplo.adapters.in.web;

import com.exemplo.application.port.in.CreateTaskUseCase;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/tasks")
public class TaskController {
    
    private final CreateTaskUseCase createTaskUseCase;
    
    @PostMapping
    public ResponseEntity&lt;TaskResponseDTO&gt; criar(@RequestBody CriarTaskDTO dto) {
        CriarTaskCommand command = new CriarTaskCommand(dto.titulo(), dto.descricao());
        Task task = createTaskUseCase.criar(command);
        return ResponseEntity.ok(TaskResponseDTO.from(task));
    }
}</pre>
                    </div>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ“ Estrutura de Pastas Completa</h2>
                
                <div class="code-block">
<pre>src/main/java/com/exemplo/
â”œâ”€â”€ domain/                      # DomÃ­nio puro
â”‚   â””â”€â”€ Task.java
â”‚
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ port/
â”‚   â”‚   â”œâ”€â”€ in/                  # Ports de entrada (Use Cases)
â”‚   â”‚   â”‚   â”œâ”€â”€ CreateTaskUseCase.java
â”‚   â”‚   â”‚   â””â”€â”€ ListTasksUseCase.java
â”‚   â”‚   â””â”€â”€ out/                 # Ports de saÃ­da (Repositories)
â”‚   â”‚       â””â”€â”€ TaskRepositoryPort.java
â”‚   â”œâ”€â”€ service/                 # ImplementaÃ§Ã£o dos Use Cases
â”‚   â”‚   â”œâ”€â”€ CreateTaskService.java
â”‚   â”‚   â””â”€â”€ ListTasksService.java
â”‚   â””â”€â”€ command/                 # Commands e DTOs de aplicaÃ§Ã£o
â”‚       â””â”€â”€ CriarTaskCommand.java
â”‚
â””â”€â”€ infrastructure/
    â”œâ”€â”€ persistence/             # Adapter de persistÃªncia
    â”‚   â”œâ”€â”€ entity/
    â”‚   â”‚   â””â”€â”€ TaskEntity.java
    â”‚   â”œâ”€â”€ repository/
    â”‚   â”‚   â”œâ”€â”€ TaskJpaRepository.java
    â”‚   â”‚   â””â”€â”€ JpaTaskRepositoryAdapter.java
    â”‚   â””â”€â”€ mapper/
    â”‚       â””â”€â”€ TaskMapper.java
    â”‚
    â””â”€â”€ adapters/
        â””â”€â”€ in/
            â””â”€â”€ web/              # Adapter de entrada (Controller)
                â”œâ”€â”€ TaskController.java
                â””â”€â”€ dto/
                    â”œâ”€â”€ CriarTaskDTO.java
                    â””â”€â”€ TaskResponseDTO.java</pre>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ”„ Fluxo de Dados</h2>
                
                <div class="concept-box">
                    <h3>Exemplo: Criar Tarefa</h3>
                    <ol>
                        <li><strong>Controller</strong> recebe requisiÃ§Ã£o HTTP</li>
                        <li><strong>Controller</strong> converte DTO â†’ Command</li>
                        <li><strong>Controller</strong> chama <code>CreateTaskUseCase</code> (port)</li>
                        <li><strong>Service</strong> implementa a lÃ³gica do use case</li>
                        <li><strong>Service</strong> cria entidade de <strong>domÃ­nio</strong></li>
                        <li><strong>Service</strong> chama <code>TaskRepositoryPort</code> (port)</li>
                        <li><strong>Adapter JPA</strong> implementa o port</li>
                        <li><strong>Adapter</strong> converte domÃ­nio â†’ entidade JPA</li>
                        <li><strong>Adapter</strong> salva no banco via JpaRepository</li>
                        <li>Retorno segue o caminho inverso</li>
                    </ol>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ§  Mini-Desafio</h2>
                <div class="challenge-box">
                    <h3>Desafio: Criar Interfaces de Ports</h3>
                    <p><strong>Objetivo:</strong> Definir os contratos da arquitetura hexagonal.</p>
                    
                    <h4>Requisitos:</h4>
                    <ol>
                        <li>Crie a entidade de domÃ­nio <code>Task</code> (sem anotaÃ§Ãµes JPA) no pacote <code>domain</code></li>
                        <li>Crie o port de saÃ­da <code>TaskRepositoryPort</code> no pacote <code>application.port.out</code> com mÃ©todos:
                            <ul>
                                <li><code>Task salvar(Task task)</code></li>
                                <li><code>Optional&lt;Task&gt; buscarPorId(Long id)</code></li>
                                <li><code>List&lt;Task&gt; listar()</code></li>
                            </ul>
                        </li>
                        <li>Crie o port de entrada <code>CreateTaskUseCase</code> no pacote <code>application.port.in</code> com mÃ©todo:
                            <ul>
                                <li><code>Task criar(CriarTaskCommand command)</code></li>
                            </ul>
                        </li>
                        <li>Crie o record <code>CriarTaskCommand</code> no pacote <code>application.command</code></li>
                        <li>Organize as pastas seguindo a estrutura hexagonal mostrada na aula</li>
                    </ol>
                </div>
            </section>

            <section class="section">
                <h2>âœ… Checklist da Aula 08</h2>
                <div class="challenge-box">
                    <p>Antes de ir para a prÃ³xima aula, certifique-se de que:</p>
                    <ul>
                        <li>âœ… Entendeu o conceito de Arquitetura Hexagonal</li>
                        <li>âœ… Entendeu a diferenÃ§a entre Domain, Application e Infrastructure</li>
                        <li>âœ… Entendeu o que sÃ£o Ports (Inbound e Outbound)</li>
                        <li>âœ… Entendeu o que sÃ£o Adapters</li>
                        <li>âœ… Entendeu o princÃ­pio de InversÃ£o de DependÃªncia</li>
                        <li>âœ… Entendeu por que separar domÃ­nio de infraestrutura</li>
                        <li>âœ… Criou estrutura de pastas hexagonal</li>
                        <li>âœ… Criou entidade de domÃ­nio pura (sem JPA)</li>
                        <li>âœ… Criou interfaces de ports (inbound e outbound)</li>
                        <li>âœ… Completou o mini-desafio de criar interfaces</li>
                    </ul>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ‘‰ Recursos Adicionais</h2>
                </div>
            </section>

            <section class="section">
                <h2>ğŸ‘‰ Recursos Adicionais</h2>
                <div class="resources-box">
                    <a href="https://www.youtube.com/results?search_query=Hexagonal+Architecture+in+Spring+Boot+Tech+Primers" target="_blank" class="resource-link">
                        ğŸ¥ Hexagonal Architecture in Spring Boot â€“ Tech Primers (YouTube)
                    </a>
                    <a href="https://alistair.cockburn.us/hexagonal-architecture/" target="_blank" class="resource-link">
                        ğŸ“– Artigo Original - Alistair Cockburn
                    </a>
                </div>
            </section>

            <nav class="lesson-nav">
                <a href="aula-07.html" class="nav-link">â† Aula Anterior</a>
                <a href="index.html" class="nav-link">Menu Principal</a>
                <a href="aula-09.html" class="nav-link">PrÃ³xima Aula â†’</a>
            </nav>
        </div>
    </div>
</body>
</html>

